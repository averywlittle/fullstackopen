{"ast":null,"code":"const initialState = ''; // Ideally, you would store this in state probably\n\nlet timerId;\nlet timerOn = false;\n\nconst reducer = (state = initialState, action) => {\n  console.log(action);\n\n  switch (action.type) {\n    case 'SHOW_NOTIFICATION':\n      {\n        return action.data;\n      }\n\n    case 'HIDE_NOTIFICATION':\n      return '';\n\n    default:\n      return state;\n  }\n}; // Sending multiple of these creates weird behavior in the notification\n// The hide function will interrupt new notifications\n// Need to get the return id, store it somewhere, and check for it before calling\n// If found, just reset the timer\n\n\nexport const showNotification = (content, time) => {\n  return async dispatch => {\n    console.log('content', content);\n    dispatch({\n      type: 'SHOW_NOTIFICATION',\n      data: content\n    });\n\n    if (timerOn) {\n      clearTimeout(timerId);\n    }\n\n    timerOn = true;\n    timerId = setTimeout(() => {\n      timerOn = false;\n      dispatch({\n        type: 'HIDE_NOTIFICATION'\n      });\n    }, time * 1000);\n    console.log(\"TIMER ID: \", timerId);\n  };\n};\nexport const hideNotification = () => {\n  return {\n    type: 'HIDE_NOTIFICATION'\n  };\n};\nexport default reducer;","map":{"version":3,"sources":["/home/averywlittle/code/fullstackopen/part7/bloglist/client/src/reducers/notificationReducer.js"],"names":["initialState","timerId","timerOn","reducer","state","action","console","log","type","data","showNotification","content","time","dispatch","clearTimeout","setTimeout","hideNotification"],"mappings":"AAAA,MAAMA,YAAY,GAAG,EAArB,C,CACA;;AACA,IAAIC,OAAJ;AACA,IAAIC,OAAO,GAAG,KAAd;;AAEA,MAAMC,OAAO,GAAG,CAACC,KAAK,GAAGJ,YAAT,EAAuBK,MAAvB,KAAkC;AAC9CC,EAAAA,OAAO,CAACC,GAAR,CAAYF,MAAZ;;AACA,UAAQA,MAAM,CAACG,IAAf;AACI,SAAK,mBAAL;AAA0B;AACtB,eAAOH,MAAM,CAACI,IAAd;AACH;;AACD,SAAK,mBAAL;AACI,aAAO,EAAP;;AACJ;AAAS,aAAOL,KAAP;AANb;AAQH,CAVD,C,CAYA;AACA;AACA;AACA;;;AACA,OAAO,MAAMM,gBAAgB,GAAG,CAACC,OAAD,EAAUC,IAAV,KAAmB;AAC/C,SAAO,MAAMC,QAAN,IAAkB;AAErBP,IAAAA,OAAO,CAACC,GAAR,CAAY,SAAZ,EAAuBI,OAAvB;AACAE,IAAAA,QAAQ,CAAC;AACLL,MAAAA,IAAI,EAAE,mBADD;AAELC,MAAAA,IAAI,EAAEE;AAFD,KAAD,CAAR;;AAKA,QAAIT,OAAJ,EAAa;AACTY,MAAAA,YAAY,CAACb,OAAD,CAAZ;AACH;;AAEDC,IAAAA,OAAO,GAAG,IAAV;AAEAD,IAAAA,OAAO,GAAGc,UAAU,CAAC,MAAM;AACvBb,MAAAA,OAAO,GAAG,KAAV;AACAW,MAAAA,QAAQ,CAAC;AACLL,QAAAA,IAAI,EAAE;AADD,OAAD,CAAR;AAGH,KALmB,EAKjBI,IAAI,GAAG,IALU,CAApB;AAOAN,IAAAA,OAAO,CAACC,GAAR,CAAY,YAAZ,EAA0BN,OAA1B;AACH,GAtBD;AAuBH,CAxBM;AA0BP,OAAO,MAAMe,gBAAgB,GAAG,MAAM;AAClC,SAAO;AACHR,IAAAA,IAAI,EAAE;AADH,GAAP;AAGH,CAJM;AAMP,eAAeL,OAAf","sourcesContent":["const initialState = ''\n// Ideally, you would store this in state probably\nlet timerId\nlet timerOn = false\n\nconst reducer = (state = initialState, action) => {\n    console.log(action)\n    switch (action.type) {\n        case 'SHOW_NOTIFICATION': {\n            return action.data\n        }\n        case 'HIDE_NOTIFICATION':\n            return ''\n        default: return state\n    }\n}\n\n// Sending multiple of these creates weird behavior in the notification\n// The hide function will interrupt new notifications\n// Need to get the return id, store it somewhere, and check for it before calling\n// If found, just reset the timer\nexport const showNotification = (content, time) => {\n    return async dispatch => {\n\n        console.log('content', content)\n        dispatch({\n            type: 'SHOW_NOTIFICATION',\n            data: content\n        })\n\n        if (timerOn) {\n            clearTimeout(timerId)\n        }\n\n        timerOn = true\n\n        timerId = setTimeout(() => {\n            timerOn = false\n            dispatch({\n                type: 'HIDE_NOTIFICATION'\n            })\n        }, time * 1000)\n\n        console.log(\"TIMER ID: \", timerId)\n    }\n}\n\nexport const hideNotification = () => {\n    return {\n        type: 'HIDE_NOTIFICATION'\n    }\n}\n\nexport default reducer"]},"metadata":{},"sourceType":"module"}